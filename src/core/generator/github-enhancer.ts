import { GeneratorOptions, ProjectProfile } from '../../types';
import { SelfHealingManager } from '../self-healing';
import YAML from 'yaml';

/**
 * Enhances a GitHub Actions workflow with additional features
 * @param workflowContent Original workflow content
 * @param projectProfile Project profile
 * @param options Generator options
 * @returns Enhanced workflow content
 */
export function enhanceGitHubWorkflow(
  workflowContent: string,
  projectProfile: ProjectProfile,
  options: GeneratorOptions
): string {
  try {
    // Parse YAML content
    let workflow: any;
    try {
      workflow = YAML.parse(workflowContent);
    } catch (error) {
      // If parsing fails, return the original content
      console.warn('Warning: Failed to parse GitHub Actions workflow YAML. Returning original content.');
      return workflowContent;
    }

    // If workflow is not valid, return the original content
    if (!workflow || !workflow.jobs) {
      return workflowContent;
    }

    // Add a comment header
    const header = `# GitHub Actions workflow generated by QForge
# Project languages: ${projectProfile.languages.join(', ')}
# Project frameworks: ${projectProfile.frameworks.join(', ')}
# Generated with options: ${JSON.stringify(options)}
`;

    // Ensure workflow runs on both push and pull_request
    if (!workflow.on || (typeof workflow.on === 'string')) {
      workflow.on = {
        push: { branches: ['main', 'master'] },
        pull_request: { branches: ['main', 'master'] }
      };
    }

    // Add self-healing capabilities if requested
    if (options.selfHealing) {
      enhanceWithSelfHealing(workflow);
    }

    // Add security scanning if requested and not already present
    if (options.security) {
      enhanceWithSecurity(workflow, projectProfile);
    }

    // Convert back to YAML
    const enhancedContent = YAML.stringify(workflow);

    // Return with header
    return header + enhancedContent;
  } catch (error) {
    // If any error occurs, return the original content
    console.warn(`Warning: Failed to enhance GitHub Actions workflow: ${error instanceof Error ? error.message : String(error)}`);
    return workflowContent;
  }
}

/**
 * Enhances a workflow with self-healing capabilities
 * @param workflow Workflow object
 */
function enhanceWithSelfHealing(workflow: any): void {
  // Add retry strategy to all jobs
  for (const jobName in workflow.jobs) {
    const job = workflow.jobs[jobName];

    // Add retry strategy to the job
    if (!job.strategy) {
      job.strategy = {};
    }

    // Add fail-fast: false to allow other jobs to continue if one fails
    job.strategy['fail-fast'] = false;

    // Add max-parallel to limit concurrent jobs
    job.strategy['max-parallel'] = 2;

    // Add retry to steps that might be flaky
    if (job.steps) {
      for (const step of job.steps) {
        // Add retry to test steps
        if (
          step.name &&
          (
            step.name.toLowerCase().includes('test') ||
            step.name.toLowerCase().includes('build') ||
            step.name.toLowerCase().includes('lint') ||
            step.name.toLowerCase().includes('deploy')
          )
        ) {
          step.continue_on_error = true;

          // If the step doesn't have an id, add one
          if (!step.id) {
            step.id = step.name.toLowerCase().replace(/\s+/g, '_');
          }

          // Add timeout to prevent hanging steps
          if (step.run && !step.timeout_minutes) {
            step.timeout_minutes = 15;
          }
        }
      }

      // Add a step to collect logs on failure
      job.steps.push({
        name: 'Collect logs on failure',
        if: 'failure()',
        run: `mkdir -p logs
find . -name "*.log" -exec cp {} logs/ \\;
find . -name "*.out" -exec cp {} logs/ \\;
find . -path "*/target/surefire-reports/*.xml" -exec cp {} logs/ \\;
find . -path "*/build/test-results/*.xml" -exec cp {} logs/ \\;
echo "Collected logs for analysis"`,
        continue_on_error: true
      });

      // Add a step to report failures
      job.steps.push({
        name: 'Report job status',
        if: 'failure()',
        run: 'echo "Job failed. Detailed analysis will be performed in the self-healing job."'
      });
    }
  }

  // Add a job for self-healing
  workflow.jobs.self_healing = {
    name: 'Self Healing',
    needs: Object.keys(workflow.jobs).filter(job => job !== 'self_healing'),
    if: 'failure()',
    runs_on: 'ubuntu-latest',
    steps: [
      {
        name: 'Checkout code',
        uses: 'actions/checkout@v3'
      },
      {
        name: 'Download logs',
        uses: 'actions/download-artifact@v3',
        with: {
          name: 'logs',
          path: 'logs'
        },
        continue_on_error: true
      },
      {
        name: 'Analyze failures',
        run: `echo "Analyzing workflow failures..."
echo "Checking for common failure patterns:"

# Check for test failures
if grep -q "FAILED" logs/*.log 2>/dev/null; then
  echo "✗ Test failures detected"
  grep -A 5 -B 5 "FAILED" logs/*.log 2>/dev/null || true
fi

# Check for dependency issues
if grep -q "Could not resolve dependencies" logs/*.log 2>/dev/null; then
  echo "✗ Dependency resolution issues detected"
  grep -A 5 -B 5 "Could not resolve dependencies" logs/*.log 2>/dev/null || true
fi

# Check for memory issues
if grep -q "Out of memory" logs/*.log 2>/dev/null; then
  echo "✗ Memory issues detected"
  grep -A 5 -B 5 "Out of memory" logs/*.log 2>/dev/null || true
fi

# Check for permission issues
if grep -q "Permission denied" logs/*.log 2>/dev/null; then
  echo "✗ Permission issues detected"
  grep -A 5 -B 5 "Permission denied" logs/*.log 2>/dev/null || true
fi

# Check for timeout issues
if grep -q "timed out" logs/*.log 2>/dev/null; then
  echo "✗ Timeout issues detected"
  grep -A 5 -B 5 "timed out" logs/*.log 2>/dev/null || true
fi

echo "Analysis complete"`,
        continue_on_error: true
      },
      {
        name: 'Suggest fixes',
        run: `echo "Suggested fixes based on analysis:"

# Test failures
echo "1. For test failures:"
echo "   - Add retries for flaky tests"
echo "   - Increase test timeouts"
echo "   - Check for race conditions in tests"
echo "   - Ensure test environment is properly set up"

# Dependency issues
echo "2. For dependency issues:"
echo "   - Update dependencies to compatible versions"
echo "   - Clear dependency caches"
echo "   - Check for network issues when fetching dependencies"
echo "   - Verify package repository access"

# Resource issues
echo "3. For resource constraints:"
echo "   - Increase memory limits"
echo "   - Optimize resource-intensive operations"
echo "   - Split large jobs into smaller ones"
echo "   - Use more powerful runners"

# Permission issues
echo "4. For permission issues:"
echo "   - Check workflow permissions"
echo "   - Verify secrets and tokens are properly set"
echo "   - Ensure file permissions are correct"
echo "   - Check service account permissions"

# Timeout issues
echo "5. For timeout issues:"
echo "   - Increase timeout limits"
echo "   - Optimize slow operations"
echo "   - Add progress reporting for long-running tasks"
echo "   - Consider breaking up long-running jobs"

echo "For more detailed analysis, run QForge locally with the --self-healing flag"`
      },
      {
        name: 'Create self-healing report',
        run: `cat > self-healing-report.md << 'EOL'
# Self-Healing Report

## Failure Analysis

The workflow failed during execution. Here's an analysis of the potential issues:

### Common Failure Patterns

- **Test Failures**: Check test logs for assertion failures or errors
- **Dependency Issues**: Verify all dependencies are correctly specified and accessible
- **Resource Constraints**: Check if jobs are running out of memory or disk space
- **Permission Problems**: Ensure the workflow has the necessary permissions
- **Configuration Errors**: Validate workflow syntax and configuration

### Recommended Actions

1. **Review Recent Changes**: Look at recent commits that might have introduced the issue
2. **Check Logs**: Examine the detailed logs for specific error messages
3. **Verify Environment**: Ensure all environment variables and secrets are properly set
4. **Test Locally**: Try to reproduce and fix the issue in a local environment
5. **Update Dependencies**: Make sure all dependencies are up to date

## Self-Healing Capabilities

This workflow includes the following self-healing capabilities:

- **Automatic Retries**: Flaky steps will be automatically retried
- **Failure Analysis**: Logs are analyzed to identify common failure patterns
- **Suggested Fixes**: Based on the analysis, specific fixes are suggested
- **Isolated Jobs**: Failures in one job won't affect others (fail-fast: false)
- **Timeout Protection**: Steps have timeouts to prevent hanging jobs

For more advanced self-healing capabilities, run QForge locally with the --self-healing flag.
EOL

echo "Self-healing report created"`,
        continue_on_error: true
      },
      {
        name: 'Upload self-healing report',
        uses: 'actions/upload-artifact@v3',
        with: {
          name: 'self-healing-report',
          path: 'self-healing-report.md'
        },
        continue_on_error: true
      }
    ]
  };

  // Add a self-healing workflow dispatch event
  if (!workflow.on || typeof workflow.on === 'string') {
    workflow.on = { workflow_dispatch: {} };
  } else if (typeof workflow.on === 'object' && !workflow.on.workflow_dispatch) {
    workflow.on.workflow_dispatch = {};
  }
}

/**
 * Enhances a workflow with security scanning
 * @param workflow Workflow object
 * @param projectProfile Project profile
 */
function enhanceWithSecurity(workflow: any, projectProfile: ProjectProfile): void {
  // Check if security scanning is already present
  let hasSecurityJob = false;
  for (const jobName in workflow.jobs) {
    if (
      jobName.toLowerCase().includes('security') ||
      jobName.toLowerCase().includes('scan')
    ) {
      hasSecurityJob = true;
      break;
    }
  }

  // If security scanning is not present, add it
  if (!hasSecurityJob) {
    workflow.jobs.security_scan = {
      name: 'Security Scan',
      runs_on: 'ubuntu-latest',
      steps: [
        {
          name: 'Checkout code',
          uses: 'actions/checkout@v3'
        }
      ]
    };

    const securitySteps = workflow.jobs.security_scan.steps;

    // Add language-specific security scanning
    if (projectProfile.languages.includes('JavaScript') || projectProfile.languages.includes('TypeScript')) {
      // Add npm audit for JavaScript/TypeScript
      securitySteps.push({
        name: 'Setup Node.js',
        uses: 'actions/setup-node@v3',
        with: {
          'node-version': '18'
        }
      });

      securitySteps.push({
        name: 'Install dependencies',
        run: 'npm ci'
      });

      securitySteps.push({
        name: 'Run npm audit',
        run: 'npm audit --audit-level=high'
      });
    }

    if (projectProfile.languages.includes('Python')) {
      // Add bandit for Python
      securitySteps.push({
        name: 'Setup Python',
        uses: 'actions/setup-python@v4',
        with: {
          'python-version': '3.10'
        }
      });

      securitySteps.push({
        name: 'Install bandit',
        run: 'pip install bandit'
      });

      securitySteps.push({
        name: 'Run bandit',
        run: 'bandit -r .'
      });
    }

    // Add CodeQL scanning for all projects
    securitySteps.push({
      name: 'Initialize CodeQL',
      uses: 'github/codeql-action/init@v2',
      with: {
        languages: projectProfile.languages.join(', ')
      }
    });

    securitySteps.push({
      name: 'Perform CodeQL Analysis',
      uses: 'github/codeql-action/analyze@v2'
    });

    // Add Dependabot alerts
    securitySteps.push({
      name: 'Check for Dependabot alerts',
      run: 'echo "Checking for Dependabot alerts. Please enable Dependabot in your repository settings."'
    });
  }
}
