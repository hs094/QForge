import { GeneratorOptions, ProjectProfile } from '../../types';
import { SelfHealingManager } from '../self-healing';
import YAML from 'yaml';

/**
 * Enhances an AWS CodePipeline configuration with additional features
 * @param pipelineContent Original pipeline content
 * @param projectProfile Project profile
 * @param options Generator options
 * @returns Enhanced pipeline content
 */
export function enhanceAwsPipeline(
  pipelineContent: string,
  projectProfile: ProjectProfile,
  options: GeneratorOptions
): string {
  try {
    // Parse YAML content
    let pipeline: any;
    try {
      pipeline = YAML.parse(pipelineContent);
    } catch (error) {
      // If parsing fails, return the original content
      console.warn('Warning: Failed to parse AWS CodePipeline YAML. Returning original content.');
      return pipelineContent;
    }

    // If pipeline is not valid, return the original content
    if (!pipeline) {
      return pipelineContent;
    }

    // Add a comment header
    const header = `# AWS CodePipeline configuration generated by QForge
# Project languages: ${projectProfile.languages.join(', ')}
# Project frameworks: ${projectProfile.frameworks.join(', ')}
# Generated with options: ${JSON.stringify(options)}
`;

    // Add security scanning if requested
    if (options.security) {
      enhanceWithSecurity(pipeline, projectProfile);
    }

    // Add self-healing capabilities if requested
    if (options.selfHealing) {
      enhanceWithSelfHealing(pipeline);
    }

    // Convert back to YAML
    const enhancedContent = YAML.stringify(pipeline);

    // Return with header
    return header + enhancedContent;
  } catch (error) {
    // If any error occurs, return the original content
    console.warn(`Warning: Failed to enhance AWS CodePipeline: ${error instanceof Error ? error.message : String(error)}`);
    return pipelineContent;
  }
}

/**
 * Enhances a pipeline with security scanning
 * @param pipeline Pipeline object
 * @param projectProfile Project profile
 */
function enhanceWithSecurity(pipeline: any, projectProfile: ProjectProfile): void {
  // Check if we have a Resources section (CloudFormation template)
  if (pipeline.Resources) {
    // Add a security scanning CodeBuild project
    pipeline.Resources.SecurityScanProject = {
      Type: 'AWS::CodeBuild::Project',
      Properties: {
        Name: { 'Fn::Sub': '${AWS::StackName}-security-scan' },
        Description: 'Security scanning for the pipeline',
        ServiceRole: { 'Fn::GetAtt': ['CodeBuildServiceRole', 'Arn'] },
        Artifacts: {
          Type: 'CODEPIPELINE'
        },
        Environment: {
          Type: 'LINUX_CONTAINER',
          ComputeType: 'BUILD_GENERAL1_SMALL',
          Image: 'aws/codebuild/amazonlinux2-x86_64-standard:3.0',
          PrivilegedMode: false
        },
        Source: {
          Type: 'CODEPIPELINE',
          BuildSpec: generateSecurityBuildSpec(projectProfile)
        }
      }
    };

    // Find the pipeline resource
    let pipelineResource;
    for (const resourceName in pipeline.Resources) {
      if (pipeline.Resources[resourceName].Type === 'AWS::CodePipeline::Pipeline') {
        pipelineResource = pipeline.Resources[resourceName];
        break;
      }
    }

    // Add security stage to the pipeline
    if (pipelineResource && pipelineResource.Properties && pipelineResource.Properties.Stages) {
      const stages = pipelineResource.Properties.Stages;

      // Add security stage before deploy stage
      const deployStageIndex = stages.findIndex((stage: any) =>
        stage.Name.toLowerCase().includes('deploy'));

      const securityStage = {
        Name: 'SecurityScan',
        Actions: [
          {
            Name: 'SecurityScan',
            ActionTypeId: {
              Category: 'Build',
              Owner: 'AWS',
              Provider: 'CodeBuild',
              Version: '1'
            },
            Configuration: {
              ProjectName: { Ref: 'SecurityScanProject' }
            },
            InputArtifacts: [
              {
                Name: 'SourceCode'
              }
            ],
            RunOrder: 1
          }
        ]
      };

      if (deployStageIndex !== -1) {
        stages.splice(deployStageIndex, 0, securityStage);
      } else {
        stages.push(securityStage);
      }
    }
  }
}

/**
 * Generates a BuildSpec for security scanning
 * @param projectProfile Project profile
 * @returns BuildSpec YAML as a string
 */
function generateSecurityBuildSpec(projectProfile: ProjectProfile): string {
  const buildSpec: any = {
    version: '0.2',
    phases: {
      install: {
        'runtime-versions': {},
        commands: []
      },
      pre_build: {
        commands: [
          'echo "Starting security scan"'
        ]
      },
      build: {
        commands: [
          'echo "Running security scans"'
        ]
      },
      post_build: {
        commands: [
          'echo "Security scan complete"'
        ]
      }
    },
    artifacts: {
      files: [
        'security-report.json'
      ]
    }
  };

  // Add language-specific security scanning
  if (projectProfile.languages.includes('JavaScript') || projectProfile.languages.includes('TypeScript')) {
    buildSpec.phases['runtime-versions'].nodejs = '18';
    buildSpec.phases.install.commands.push('npm install -g npm-audit-html');
    buildSpec.phases.build.commands.push('npm ci');
    buildSpec.phases.build.commands.push('npm audit --json > npm-audit.json || true');
    buildSpec.phases.build.commands.push('npm-audit-html -o security-report.html -j npm-audit.json');
  }

  if (projectProfile.languages.includes('Python')) {
    buildSpec.phases['runtime-versions'].python = '3.10';
    buildSpec.phases.install.commands.push('pip install bandit safety');
    buildSpec.phases.build.commands.push('bandit -r . -f json -o bandit-report.json || true');
    buildSpec.phases.build.commands.push('safety check --json > safety-report.json || true');
  }

  return YAML.stringify(buildSpec);
}

/**
 * Enhances a pipeline with self-healing capabilities
 * @param pipeline Pipeline object
 */
function enhanceWithSelfHealing(pipeline: any): void {
  // Check if we have a Resources section (CloudFormation template)
  if (pipeline.Resources) {
    // Add a self-healing Lambda function with advanced failure analysis
    pipeline.Resources.SelfHealingFunction = {
      Type: 'AWS::Lambda::Function',
      Properties: {
        Handler: 'index.handler',
        Role: { 'Fn::GetAtt': ['LambdaExecutionRole', 'Arn'] },
        Code: {
          ZipFile: `
const AWS = require('aws-sdk');
const codepipeline = new AWS.CodePipeline();
const cloudwatchlogs = new AWS.CloudWatchLogs();
const sns = new AWS.SNS();

// Failure patterns to check for
const FAILURE_PATTERNS = {
  TEST: [/test(s)?\\s+failed/i, /failing\\s+test(s)?/i, /assertion\\s+failed/i],
  BUILD: [/build\\s+failed/i, /compilation\\s+failed/i, /cannot\\s+find\\s+module/i],
  DEPENDENCY: [/could\\s+not\\s+resolve\\s+dependencies/i, /package\\s+not\\s+found/i],
  RESOURCE: [/out\\s+of\\s+memory/i, /memory\\s+limit\\s+exceeded/i, /disk\\s+space\\s+limit\\s+exceeded/i],
  NETWORK: [/network\\s+error/i, /connection\\s+refused/i, /connection\\s+timed\\s+out/i],
  PERMISSION: [/permission\\s+denied/i, /insufficient\\s+permissions/i, /not\\s+authorized/i],
  TIMEOUT: [/timeout\\s+exceeded/i, /timed\\s+out/i, /execution\\s+timed\\s+out/i]
};

// Fix suggestions for different failure types
const FIX_SUGGESTIONS = {
  TEST: [
    "Add retry logic for flaky tests",
    "Increase test timeouts",
    "Check for race conditions in tests",
    "Ensure test environment is properly set up"
  ],
  BUILD: [
    "Fix compilation errors",
    "Update build configuration",
    "Clean build cache",
    "Check for compatibility issues between dependencies"
  ],
  DEPENDENCY: [
    "Update dependencies to compatible versions",
    "Clear dependency caches",
    "Check for network issues when fetching dependencies",
    "Verify package repository access"
  ],
  RESOURCE: [
    "Increase memory limits",
    "Optimize resource-intensive operations",
    "Split large jobs into smaller ones",
    "Use more powerful compute resources"
  ],
  NETWORK: [
    "Implement retries for network operations",
    "Use reliable package sources",
    "Check service status",
    "Implement circuit breakers for unreliable services"
  ],
  PERMISSION: [
    "Update IAM permissions",
    "Check for expired credentials",
    "Verify that environment variables for authentication are set correctly",
    "Check service account permissions"
  ],
  TIMEOUT: [
    "Increase timeouts for long-running operations",
    "Split long-running jobs into smaller ones",
    "Implement progress reporting",
    "Optimize performance of slow operations"
  ]
};

/**
 * Gets logs for a CodeBuild project
 * @param {string} projectName CodeBuild project name
 * @param {string} buildId Build ID
 * @returns {Promise<string>} Logs as a string
 */
async function getCodeBuildLogs(projectName, buildId) {
  try {
    // Get the log group and stream name for the build
    const logGroupName = \`/aws/codebuild/\${projectName}\`;
    const logStreamName = buildId.split(':').pop();

    // Get log events
    const params = {
      logGroupName,
      logStreamName,
      limit: 1000
    };

    const logEvents = await cloudwatchlogs.getLogEvents(params).promise();

    // Combine log messages
    return logEvents.events.map(event => event.message).join('\\n');
  } catch (error) {
    console.error('Error getting CodeBuild logs:', error);
    return 'Error retrieving logs';
  }
}

/**
 * Analyzes logs for failure patterns
 * @param {string} logs Logs to analyze
 * @returns {Object} Analysis results
 */
function analyzeFailureLogs(logs) {
  const detectedFailures = [];

  // Check each failure pattern
  for (const [failureType, patterns] of Object.entries(FAILURE_PATTERNS)) {
    for (const pattern of patterns) {
      if (pattern.test(logs)) {
        detectedFailures.push({
          type: failureType,
          pattern: pattern.toString(),
          message: logs.match(pattern)[0],
          suggestions: FIX_SUGGESTIONS[failureType] || []
        });
      }
    }
  }

  return {
    detectedFailures,
    timestamp: new Date().toISOString(),
    summary: detectedFailures.length > 0
      ? \`Detected \${detectedFailures.length} potential failure patterns\`
      : "No specific failure patterns detected"
  };
}

exports.handler = async (event) => {
  console.log('Received event:', JSON.stringify(event, null, 2));

  // Extract pipeline details from the event
  const pipelineName = event.detail.pipeline;
  const stage = event.detail.stage;
  const action = event.detail.action;
  const state = event.detail.state;

  if (state === 'FAILED') {
    console.log(\`Pipeline \${pipelineName} failed at stage \${stage}, action \${action}\`);

    // Get more details about the failed action
    const pipelineState = await codepipeline.getPipelineState({ name: pipelineName }).promise();
    const stageState = pipelineState.stageStates.find(s => s.stageName === stage);

    if (stageState && stageState.actionStates) {
      const actionState = stageState.actionStates.find(a => a.actionName === action);

      if (actionState && actionState.latestExecution && actionState.latestExecution.errorDetails) {
        const errorMessage = actionState.latestExecution.errorDetails.message;
        console.log(\`Error message: \${errorMessage}\`);

        // Analyze the error message
        const analysis = analyzeFailureLogs(errorMessage);
        console.log('Analysis:', JSON.stringify(analysis, null, 2));

        // If it's a CodeBuild action, get the logs
        if (actionState.actionName.includes('Build') || actionState.actionName.includes('Test')) {
          // Get the CodeBuild project name and build ID
          // This is a simplified example - in a real implementation,
          // you would need to get these details from the action configuration
          const projectName = actionState.actionName;
          const buildId = actionState.latestExecution.externalExecutionId;

          if (buildId) {
            console.log(\`Getting logs for build \${buildId}\`);
            const logs = await getCodeBuildLogs(projectName, buildId);

            // Analyze the logs
            const logsAnalysis = analyzeFailureLogs(logs);
            console.log('Logs analysis:', JSON.stringify(logsAnalysis, null, 2));

            // Combine the analyses
            analysis.detectedFailures = [...analysis.detectedFailures, ...logsAnalysis.detectedFailures];
          }
        }

        // Implement retry logic based on the analysis
        if (analysis.detectedFailures.some(f =>
          f.type === 'TEST' ||
          f.type === 'NETWORK' ||
          f.type === 'TIMEOUT'
        )) {
          console.log('Detected failure type that may benefit from retry. Attempting to retry...');

          try {
            // Retry the failed stage
            await codepipeline.retryStageExecution({
              pipelineName: pipelineName,
              stageName: stage,
              retryMode: 'FAILED_ACTIONS'
            }).promise();

            console.log('Retry initiated successfully');
            return { status: 'SUCCESS', message: 'Retry initiated', analysis };
          } catch (error) {
            console.error('Error retrying stage:', error);
            return { status: 'ERROR', message: error.message, analysis };
          }
        } else {
          console.log('Failure type does not benefit from automatic retry');
          return { status: 'INFO', message: 'No automatic retry performed', analysis };
        }
      }
    }

    // Fallback to simple retry logic if we couldn't get detailed information
    if (action.includes('Test') || action.includes('Build')) {
      console.log('Attempting to retry the failed action...');

      try {
        // Retry the failed stage
        await codepipeline.retryStageExecution({
          pipelineName: pipelineName,
          stageName: stage,
          retryMode: 'FAILED_ACTIONS'
        }).promise();

        console.log('Retry initiated successfully');
        return { status: 'SUCCESS', message: 'Retry initiated' };
      } catch (error) {
        console.error('Error retrying stage:', error);
        return { status: 'ERROR', message: error.message };
      }
    }
  }

  return { status: 'SUCCESS', message: 'No action needed' };
};
          `
        },
        Runtime: 'nodejs18.x',
        Timeout: 60,
        MemorySize: 256,
        Environment: {
          Variables: {
            LOG_LEVEL: 'INFO',
            MAX_RETRIES: '3'
          }
        }
      }
    };

    // Add Lambda execution role with enhanced permissions
    pipeline.Resources.LambdaExecutionRole = {
      Type: 'AWS::IAM::Role',
      Properties: {
        AssumeRolePolicyDocument: {
          Version: '2012-10-17',
          Statement: [
            {
              Effect: 'Allow',
              Principal: {
                Service: 'lambda.amazonaws.com'
              },
              Action: 'sts:AssumeRole'
            }
          ]
        },
        ManagedPolicyArns: [
          'arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole'
        ],
        Policies: [
          {
            PolicyName: 'CodePipelineAccess',
            PolicyDocument: {
              Version: '2012-10-17',
              Statement: [
                {
                  Effect: 'Allow',
                  Action: [
                    'codepipeline:GetPipelineState',
                    'codepipeline:GetPipelineExecution',
                    'codepipeline:RetryStageExecution',
                    'codepipeline:ListActionExecutions',
                    'codepipeline:ListPipelineExecutions'
                  ],
                  Resource: '*'
                }
              ]
            }
          },
          {
            PolicyName: 'CloudWatchLogsAccess',
            PolicyDocument: {
              Version: '2012-10-17',
              Statement: [
                {
                  Effect: 'Allow',
                  Action: [
                    'logs:GetLogEvents',
                    'logs:FilterLogEvents',
                    'logs:DescribeLogGroups',
                    'logs:DescribeLogStreams'
                  ],
                  Resource: '*'
                }
              ]
            }
          },
          {
            PolicyName: 'CodeBuildAccess',
            PolicyDocument: {
              Version: '2012-10-17',
              Statement: [
                {
                  Effect: 'Allow',
                  Action: [
                    'codebuild:BatchGetBuilds',
                    'codebuild:ListBuildsForProject'
                  ],
                  Resource: '*'
                }
              ]
            }
          },
          {
            PolicyName: 'SNSPublish',
            PolicyDocument: {
              Version: '2012-10-17',
              Statement: [
                {
                  Effect: 'Allow',
                  Action: 'sns:Publish',
                  Resource: '*'
                }
              ]
            }
          }
        ]
      }
    };

    // Add CloudWatch Event Rule to trigger Lambda on pipeline failure
    pipeline.Resources.PipelineFailureEventRule = {
      Type: 'AWS::Events::Rule',
      Properties: {
        Description: 'Trigger self-healing on pipeline failure',
        EventPattern: {
          source: ['aws.codepipeline'],
          'detail-type': ['CodePipeline Action Execution State Change'],
          detail: {
            state: ['FAILED']
          }
        },
        State: 'ENABLED',
        Targets: [
          {
            Arn: { 'Fn::GetAtt': ['SelfHealingFunction', 'Arn'] },
            Id: 'SelfHealingFunction'
          }
        ]
      }
    };

    // Add permission for CloudWatch Events to invoke Lambda
    pipeline.Resources.LambdaPermission = {
      Type: 'AWS::Lambda::Permission',
      Properties: {
        Action: 'lambda:InvokeFunction',
        FunctionName: { Ref: 'SelfHealingFunction' },
        Principal: 'events.amazonaws.com',
        SourceArn: { 'Fn::GetAtt': ['PipelineFailureEventRule', 'Arn'] }
      }
    };

    // Add SNS topic for failure notifications
    pipeline.Resources.PipelineNotificationTopic = {
      Type: 'AWS::SNS::Topic',
      Properties: {
        DisplayName: 'Pipeline Failure Notifications',
        TopicName: { 'Fn::Join': ['-', ['pipeline-failures', { Ref: 'AWS::StackName' }]] }
      }
    };

    // Add DynamoDB table for tracking failures and retries
    pipeline.Resources.FailureTrackingTable = {
      Type: 'AWS::DynamoDB::Table',
      Properties: {
        AttributeDefinitions: [
          {
            AttributeName: 'PipelineExecutionId',
            AttributeType: 'S'
          },
          {
            AttributeName: 'FailureTimestamp',
            AttributeType: 'S'
          }
        ],
        KeySchema: [
          {
            AttributeName: 'PipelineExecutionId',
            KeyType: 'HASH'
          },
          {
            AttributeName: 'FailureTimestamp',
            KeyType: 'RANGE'
          }
        ],
        BillingMode: 'PAY_PER_REQUEST',
        TimeToLiveSpecification: {
          AttributeName: 'ExpirationTime',
          Enabled: true
        }
      }
    };

    // Add a Lambda function for generating self-healing reports
    pipeline.Resources.SelfHealingReportFunction = {
      Type: 'AWS::Lambda::Function',
      Properties: {
        Handler: 'index.handler',
        Role: { 'Fn::GetAtt': ['LambdaExecutionRole', 'Arn'] },
        Runtime: 'nodejs18.x',
        Timeout: 60,
        MemorySize: 256,
        Environment: {
          Variables: {
            NOTIFICATION_TOPIC_ARN: { Ref: 'PipelineNotificationTopic' },
            FAILURE_TRACKING_TABLE: { Ref: 'FailureTrackingTable' }
          }
        },
        Code: {
          ZipFile: `
const AWS = require('aws-sdk');
const dynamodb = new AWS.DynamoDB.DocumentClient();
const sns = new AWS.SNS();

/**
 * Generates a self-healing report for a pipeline
 * @param {Object} event Event data
 * @returns {Object} Response
 */
exports.handler = async (event) => {
  console.log('Generating self-healing report...');
  console.log('Event:', JSON.stringify(event, null, 2));

  try {
    // Get pipeline name from event or use default
    const pipelineName = event.pipelineName || 'Unknown';

    // Get failure history from DynamoDB
    const failureHistory = await getFailureHistory(pipelineName);

    // Generate report
    const report = generateReport(pipelineName, failureHistory);

    // Publish report to SNS
    await publishReport(report);

    return {
      statusCode: 200,
      body: JSON.stringify({
        message: 'Self-healing report generated and published',
        pipelineName,
        failureCount: failureHistory.length
      })
    };
  } catch (error) {
    console.error('Error generating self-healing report:', error);

    return {
      statusCode: 500,
      body: JSON.stringify({
        message: 'Error generating self-healing report',
        error: error.message
      })
    };
  }
};

/**
 * Gets failure history for a pipeline
 * @param {string} pipelineName Pipeline name
 * @returns {Promise<Array>} Failure history
 */
async function getFailureHistory(pipelineName) {
  // Query DynamoDB for failure history
  // This is a simplified implementation
  const params = {
    TableName: process.env.FAILURE_TRACKING_TABLE,
    Limit: 10,
    ScanIndexForward: false // Get most recent failures first
  };

  try {
    const result = await dynamodb.scan(params).promise();
    return result.Items || [];
  } catch (error) {
    console.error('Error getting failure history:', error);
    return [];
  }
}

/**
 * Generates a self-healing report
 * @param {string} pipelineName Pipeline name
 * @param {Array} failureHistory Failure history
 * @returns {string} Markdown report
 */
function generateReport(pipelineName, failureHistory) {
  const timestamp = new Date().toISOString();

  let report = \`# Self-Healing Report for \${pipelineName}

## Overview
- **Pipeline**: \${pipelineName}
- **Report Generated**: \${timestamp}
- **Failures Analyzed**: \${failureHistory.length}

## Failure Analysis\`;

  if (failureHistory.length > 0) {
    // Group failures by type
    const failuresByType = {};

    for (const failure of failureHistory) {
      const type = failure.FailureType || 'Unknown';

      if (!failuresByType[type]) {
        failuresByType[type] = [];
      }

      failuresByType[type].push(failure);
    }

    // Add failure summary by type
    report += \`

### Failure Summary by Type\`;

    for (const [type, failures] of Object.entries(failuresByType)) {
      report += \`

#### \${type} Failures (\${failures.length})
- **Frequency**: \${Math.round(failures.length / failureHistory.length * 100)}% of all failures
- **Most Recent**: \${failures[0].FailureTimestamp || 'Unknown'}\`;

      if (failures[0].Suggestions && failures[0].Suggestions.length > 0) {
        report += \`
- **Suggested Fixes**:
\${failures[0].Suggestions.map(suggestion => \`  - \${suggestion}\`).join('\\n')}\`;
      }
    }

    // Add recent failures
    report += \`

### Recent Failures\`;

    for (let i = 0; i < Math.min(5, failureHistory.length); i++) {
      const failure = failureHistory[i];

      report += \`

#### Failure on \${failure.FailureTimestamp || 'Unknown'}
- **Type**: \${failure.FailureType || 'Unknown'}
- **Stage**: \${failure.StageName || 'Unknown'}
- **Action**: \${failure.ActionName || 'Unknown'}
- **Message**: \${failure.ErrorMessage || 'No error message available'}
- **Retry Attempted**: \${failure.RetryAttempted ? 'Yes' : 'No'}
- **Retry Successful**: \${failure.RetrySuccessful ? 'Yes' : 'No'}\`;
    }
  } else {
    report += \`

No failures have been recorded for this pipeline. This is either a new pipeline or it has been running successfully.
\`;
  }

  report += \`

## Self-Healing Capabilities

This pipeline includes the following self-healing capabilities:

- **Automatic Analysis**: Pipeline failures are automatically analyzed
- **Failure Pattern Detection**: Common failure patterns are identified
- **Suggested Fixes**: Based on the analysis, specific fixes are suggested
- **Automatic Retries**: Certain types of failures are automatically retried
- **Failure Tracking**: Pipeline failures are tracked for trend analysis
- **Notifications**: Failure notifications are sent via SNS

For more advanced self-healing capabilities, run QForge locally with the --self-healing flag.\`;

  return report;
}

/**
 * Publishes a report to SNS
 * @param {string} report Markdown report
 * @returns {Promise<Object>} SNS publish result
 */
async function publishReport(report) {
  const params = {
    TopicArn: process.env.NOTIFICATION_TOPIC_ARN,
    Subject: 'Pipeline Self-Healing Report',
    Message: report
  };

  return sns.publish(params).promise();
}
          `
        }
      }
    };

    // Add CloudWatch scheduled event to trigger report generation
    pipeline.Resources.SelfHealingReportSchedule = {
      Type: 'AWS::Events::Rule',
      Properties: {
        Description: 'Generate self-healing report on a schedule',
        ScheduleExpression: 'rate(1 day)',
        State: 'ENABLED',
        Targets: [
          {
            Arn: { 'Fn::GetAtt': ['SelfHealingReportFunction', 'Arn'] },
            Id: 'SelfHealingReportFunction'
          }
        ]
      }
    };

    // Add permission for CloudWatch Events to invoke the report function
    pipeline.Resources.SelfHealingReportPermission = {
      Type: 'AWS::Lambda::Permission',
      Properties: {
        Action: 'lambda:InvokeFunction',
        FunctionName: { Ref: 'SelfHealingReportFunction' },
        Principal: 'events.amazonaws.com',
        SourceArn: { 'Fn::GetAtt': ['SelfHealingReportSchedule', 'Arn'] }
      }
    };
  }
}
